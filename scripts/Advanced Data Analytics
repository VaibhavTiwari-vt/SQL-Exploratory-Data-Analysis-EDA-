/*
Purpose : Perform advance analytic and create a view for customer and product report to answer the business questions and for the use of other members in the company.
*/

-- ###################### CHANGE OVER TIME (TRENDS) ################################
select YEAR(order_date) as order_year, 
MONTH(order_date) as order_month,
sum(sales_amount) as total_sales,
count(distinct customer_key) as total_customers,
sum(quantity) as total_quantity from gold.fact_sales 
where order_date is not null group by YEAR(order_date),MONTH(order_date) order by YEAR(order_date),MONTH(order_date);

select DATETRUNC(month,order_date) as order_date, 
sum(sales_amount) as total_sales,
count(distinct customer_key) as total_customers,
sum(quantity) as total_quantity from gold.fact_sales 
where order_date is not null group by DATETRUNC(month,order_date) order by DATETRUNC(month,order_date);

-- How many new customers were added each year?
select FORMAT(order_date,'yyyy-MMM') as order_date, 
sum(sales_amount) as total_sales,
count(distinct customer_key) as total_customers,
sum(quantity) as total_quantity from gold.fact_sales 
where order_date is not null group by FORMAT(order_date,'yyyy-MMM') order by FORMAT(order_date,'yyyy-MMM');

-- ###################### CUMULATIVE ANALYSIS ################################

--Calculate the total sales per month and the running total of sales over time.
select order_date,
total_sales,
sum(total_sales) over(partition by year(order_date) order by order_date rows between unbounded preceding and current row) as cumulative_sales,
avg(avg_price) over(partition by year(order_date) order by order_date) as moving_average
from(
SELECT
DATETRUNC(month,order_date) as order_date,
sum(sales_amount) as total_sales,
avg(price) as avg_price
from gold.fact_sales where order_date is not null
group by DATETRUNC(month,order_date))t;

-- ###################### PERFORMANCE ANALYSIS ################################

--Analyze the yearly performance of products by comparing each product's sales to both its average sales performance and the previours year's sales
with year_product_sales as(
select
year(f.order_date) as order_year,
p.product_name,
sum(f.sales_amount) as current_sales
from gold.fact_sales f
left join gold.dim_products p
on f.product_key=p.product_key
where f.order_date is not null
group by year(f.order_date),p.product_name)

select order_year,product_name,current_sales,
avg(current_sales) over(partition by product_name) as avg_sales,
current_sales - AVG(current_sales) over(partition by product_name) as diff_avg,
case when current_sales - AVG(current_sales) over(partition by product_name) >0 then 'Above Average'
	when current_sales - AVG(current_sales) over(partition by product_name) <0 then 'Below Average'
	else 'Average' end as avg_change,
-- Year-over-Year Analysis
lag(current_sales) over(partition by product_name order by order_year) as py_sales,
current_sales - lag(current_sales) over(partition by product_name order by order_year) as diff_py,
case when current_sales - lag(current_sales) over(partition by product_name order by order_year) >0 then 'Increase'
	when current_sales - lag(current_sales) over(partition by product_name order by order_year) <0 then 'Decrease'
	else 'No Change' end as py_change
from year_product_sales order by product_name,order_year

-- ###################### Part-To-Whole ################################

--Which category contribute the most to overall sales.
with category_sales as (select
category,
sum(sales_amount) as total_sales
from gold.fact_sales f
left join gold.dim_products p
on p.product_key=f.product_key
group by category)

select
category,
total_sales,
sum(total_sales) over() overall_sales,
concat(round((cast(total_sales as float)/sum(total_sales) over())*100,2),'%') as percentage_of_total
from category_sales order by total_sales desc

-- ###################### Part-To-Whole ################################

--Segment products into cost ranges and count how many products fall into each category
with product_segment as (select 
product_key,
product_name,
cost,
case when cost<100 then 'Below 100'
	when cost between 100 and 500 then '100-500'
	when cost between 500 and 1000 then '500-1000'
	else 'Above 1000' end as cost_range
from gold.dim_products)

select
cost_range,
count(product_key) as total_products
from product_segment
group by cost_range order by total_products desc

/*Group customers into three segments based on their spending behaviour :
	- VIP: Customers with at least 12 months of history and spending more than $5000.
	-Regular: Customers with atleast 12 months of history but spending $5000 or less.
	-New: Customers with a lifespan less than 12 months.
And find the total number of customers by each group */
with customer_segement as (
select
c.customer_key,
sum(f.sales_amount) total_spending,
min(f.order_date) first_order,
max(f.order_date) last_order,
datediff(month,min(f.order_date),max(f.order_date)) as lifespan
from gold.fact_sales f left join gold.dim_customers c on f.customer_key=c.customer_key
group by c.customer_key
)
select customer_seg,count(customer_key) as total_customers from 
(select 
customer_key,
case when lifespan>=12 and total_spending>5000 then 'VIP'
	 when lifespan>=12 and total_spending<=5000 then 'Regular'
	 else 'New' end as customer_seg
from customer_segement)t group by customer_seg order by count(customer_key) desc;
